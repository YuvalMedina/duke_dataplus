x <- 2^rnorm(100)
fhat <- kde(x=x, positive=TRUE)
install.packages('kde')
setRepositories()
ap<-available.packages()
View(ap)
install.packages('kdensity')
fhat <- kde(x=x, positive=TRUE)
install.packages('ks')
fhat <- kde(x=x, positive=TRUE)
help(package = ks)
install.packages(ks)
install.packages("ks")
lsf.str("package:ks")
library(ks)
# NOT RUN {
## positive data example
set.seed(8192)
x <- 2^rnorm(100)
fhat <- kde(x=x, positive=TRUE)
instalplot(fhat, col=3)
plot(fhat, col=3)
points(c(0.5, 1), predict(fhat, x=c(0.5, 1)))
## large data example on non-default grid
## 151 x 151 grid = [-5,-4.933,..,5] x [-5,-4.933,..,5]
set.seed(8192)
x <- rmvnorm.mixt(10000, mus=c(0,0), Sigmas=invvech(c(1,0.8,1)))
fhat <- kde(x=x, binned=TRUE, compute.cont=TRUE, xmin=c(-5,-5), xmax=c(5,5), bgridsize=c(151,151))
plot(fhat)
View(x)
View(x)
corr_dat <- data.frame(disch = disch$value,
DO = DO$value)
fhat <- kde(x=corr_dat, binned=TRUE, compute.cont=TRUE, bgridsize=c(151,151))
library(ks)
fhat <- kde(x=corr_dat, binned=TRUE, compute.cont=TRUE, bgridsize=c(151,151))
fhat <- kde(x=corr_dat)
View(x)
corr_mat <- data.matrix(corr_dat)
fhat <- kde(x=corr_mat)
View(corr_mat)
fhat <- kde(x=corr_mat, positive = FALSE)
View(x)
fhat <- kde(x=corr_mat)
#function to fill missing time stamps with NA
fill_time <- function(raw_dat){
time_interval = as.numeric(difftime(raw_dat$dateTimeUTC[2],
raw_dat$dateTimeUTC[1]))
full_dat = seq.POSIXt(raw_dat$dateTimeUTC[1],
raw_dat$dateTimeUTC[nrow(raw_dat)], by=paste(time_interval, 'min'))
filled = full_join(data.frame(dateTimeUTC=full_dat), raw_dat)
filled
}
corr_dat <- data.frame(disch = disch$value,
DO = DO$value)
corr_dat <- corr_dat[complete.cases(corr_dat),]
corr_mat <- data.matrix(corr_dat)
fhat <- kde(x=corr_mat)
plot(fhat)
View(corr_dat)
corr_mat <- data.matrix(corr_dat, xmax=40)
fhat <- kde(x=corr_mat, xmax=40)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=0, xmax=40)
fhat <- kde(x=corr_mat)
plot(fhat)
library(ks)
# NOT RUN {
## positive data example
set.seed(8192)
x <- 2^rnorm(100)
fhat <- kde(x=x, positive=TRUE)
plot(fhat, col=3)
points(c(0.5, 1), predict(fhat, x=c(0.5, 1)))
## large data example on non-default grid
## 151 x 151 grid = [-5,-4.933,..,5] x [-5,-4.933,..,5]
set.seed(8192)
x <- rmvnorm.mixt(10000, mus=c(0,0), Sigmas=invvech(c(1,0.8,1)))
fhat <- kde(x=x, binned=TRUE, compute.cont=TRUE, xmin=c(-5,-5), xmax=c(5,5), bgridsize=c(151,151))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(0,0), xmax=c(20,10),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(30,20),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(30,30),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(40,30),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(50,30),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(100,30),)
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(100,30))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(100,15))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(10,15))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(4,15))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(4,12))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-2,-2), xmax=c(4,13))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(4,13))
plot(fhat)
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(3,13))
plot(fhat)
View(fhat)
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(3,13))
plot(fhat, display="slice", cont=c(25,50,75), abs.cont, approx.cont=TRUE,
xlab, ylab, zlab="Density function", cex=1, pch=1, add=FALSE,
drawpoints=FALSE, drawlabels=TRUE, theta=-30, phi=40, d=4, col.pt="blue",
col, col.fun, lwd=1, border=1, thin=3, lwd.fc=5, ...)
plot(fhat, display="slice", cont=c(25,50,75), abs.cont, approx.cont=TRUE,
xlab, ylab, zlab="Density function", cex=1, pch=1, add=FALSE,
drawpoints=FALSE, drawlabels=TRUE, theta=-30, phi=40, d=4, col.pt="blue",
col, col.fun, lwd=1, border=1, thin=3, lwd.fc=5)
plot(fhat, display="slice", cont=c(25,50,75), abs.cont, approx.cont=TRUE,
xlab, ylab, zlab="Density function", cex=1, pch=1, add=FALSE,
drawpoints=FALSE, drawlabels=TRUE, theta=-30, phi=40, d=4, col.pt="blue",
col, col.fun, lwd=1, border=1, thin=3, lwd.fc=5)
plot(fhat, display="slice", cont=c(25,50,75),
xlab, ylab)
plot(fhat,  cont=c(25,50,75),
xlab, ylab)
plot(fhat,  cont=c(25,50,75, 95))
plot(fhat,  cont=c(25,50,95))
plot(fhat,  cont=c(25,50,75,95))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(30,30))
plot(fhat,  cont=c(25,50,75,95))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(10,30))
plot(fhat,  cont=c(25,50,75,95))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(10,17))
plot(fhat,  cont=c(25,50,75,95))
plot(fhat,  cont=c(25,50,75,95, 100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(10,17))
plot(fhat,  cont=c(25,50,75,95, 100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(30,30))
plot(fhat,  cont=c(25,50,75,95, 100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c40,40))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(40,40))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(100,100))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(300,300))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(30,30))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-1,-2), xmax=c(10,16))
plot(fhat,  cont=c(25,50,75,95,100))
fhat <- kde(x=corr_mat, xmin=c(-5,-5), xmax=c(10,16))
plot(fhat,  cont=c(25,50,75,95,100))
plot(fhat,  cont=c(25,50,75,95,100), col="white")
plot(fhat,  cont=c(25,50,75,95,100), col="blue")
plot(fhat,  cont=c(25,50,75,95,100), col="black")
plot(fhat,  cont=c(25,50,75,95,100), col="black", col.fun="blue")
fhat <- kde(x=corr_mat, xmin=c(-5,-5), xmax=c(10,16))
plot(fhat,  cont=c(25,50,75,95,100), col="black", col.fun="blue")
plot(fhat,  cont=c(25,50,75,95,100), col="black", col.fun=topo.colors)
fhat <- kde(x=corr_mat, xmin=c(-5,-5), xmax=c(10,16))
plot(fhat,  cont=c(25,50,75,95,100), col="black", col.fun=topo.colors)
plot(fhat,  cont=c(25,50,75,90,100), col="black")
plot(fhat,  cont=c(25,50,75,90,98), col="black")
plot(fhat,  cont=c(25,50,75,90,96), col="black")
full_dat = seq.POSIXt(raw_dat$dateTimeUTC[1],
raw_dat$dateTimeUTC[nrow(raw_dat)], by=paste(time_interval, 'min'))
plot(fhat,  cont=c(25,50,75,90,97), col="black")
plot(fhat,  cont=c(25,50,75,90,98), col="black")
plot(fhat,  cont=c(25,50,75,90,97), col="black")
plot(fhat,  cont=c(25,50,75,97), col="black")
plot(fhat,  cont=c(25,50,75,95, 97), col="black")
fhat <- kde(x=corr_mat, xmin=c(-100,-100), xmax=c(100,100))
plot(fhat,  cont=c(25,50,75,95, 97), col="black")
plot(fhat,  cont=c(25,50,75,95, 100), col="black")
plot(fhat,  cont=c(25,50,75,97), col="black")
fhat <- kde(x=corr_mat, xmin=c(-5,-5), xmax=c(10,16))
plot(fhat,  cont=c(25,50,75,97), col="black")
plot(fhat,  cont=c(25,50,75,97), col="black", display="filled.contour2")
plot(fhat,  cont=c(25,50,75,97), col="black", display="filled.contour")
plot(fhat,  cont=c(25,50,75,97), col="black", display="filled.contour1")
plot(fhat,  cont=c(25,50,75,97), col="black", display="slice")
plot(fhat,  cont=c(25,50,75,97), col="black", display="image")
plot(fhat,  cont=c(25,50,75,97), col="black", display="persp")
plot(fhat,  cont=c(25,50,75,97), col="black", display="filled.contour2")
plot(fhat,  cont=c(25,50,75,97), col="white", display="filled.contour2")
plot(fhat,  cont=c(25,50,75,95), col="white", display="filled.contour2")
plot(fhat,  cont=c(25,50,75,95), col="white", drawpoints=TRUE)
plot(fhat,  cont=c(25,50,75,95), col="black", thin=3)
plot(fhat,  abs.cont=c(25,50,75,95), col="black", thin=3)
plot(fhat,  cont=c(25,50,75,95), col="black", thin=3)
contourSizes(fhat, abs.cont, cont=c(25,50,75, 95), approx=TRUE)
contourSizes(fhat, cont=c(25,50,75, 95), approx=TRUE)
plot(fhat,  cont=c(25,50,75,95), col="black", compute.cont=TRUE)
fhat <- kde(x=corr_mat)
plot(fhat,  cont=c(25,50,75,95), col="black", compute.cont=TRUE)
fhat <- kde(x=corr_mat, compute.cont=TRUE)
contour.95 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["95%"])[[1]])
View(contour.95)
View(corr_dat)
View(fhat)
View(fhat)
z=estimate,levels=c(cont["96%"],cont["97%"],cont["98%"],cont["99%"])[[1]])
z=estimate,levels=c(cont["96%"][[1]],cont["97%"][[1]],cont["98%"][[1]],cont["99%"][[1]]))
plot(fhat,  cont=c(25,50,75,95), col="black")
contour.95 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["95%"])[[1]])
View(contour.95)
contour.96 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["96%"])[[1]])
View(contour.96)
View(contour.95)
n <- 200
set.seed(35233)
x <- mvtnorm::rmvnorm(n = n, mean = c(0, 0),
sigma = rbind(c(1.5, 0.25), c(0.25, 0.5)))
View(x)
View(x)
# Compute kde for a diagonal bandwidth matrix (trivially positive definite)
H <- diag(c(1.25, 0.75))
View(H)
kde <- ks::kde(x = x, H = H)
View(kde)
# The eval.points slot contains the grids on x and y
str(kde$eval.points)
# The grids in kde$eval.points are crossed in order to compute a grid matrix
# where to compute the estimate
dim(kde$estimate)
# Manual plotting using the kde object structure
image(kde$eval.points[[1]], kde$eval.points[[2]], kde$estimate,
col = viridis::viridis(20), xlab = "x", ylab = "y")
library(viridis)
install.packages('viridis')
# Manual plotting using the kde object structure
image(kde$eval.points[[1]], kde$eval.points[[2]], kde$estimate,
col = viridis::viridis(20), xlab = "x", ylab = "y")
points(kde$x) # The data is returned in $x
points(fhat$x)
plot(fhat,  cont=c(25,50,75,95), col="black")
points(fhat$x)
View(fhat)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
+       col = viridis::viridis(20), xlab = "x", ylab = "y")
library(viridis)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
+col = viridis::viridis(20), xlab = "x", ylab = "y")
#remove rows with NA for any variables
remove_na <- function(raw_dat){
raw_dat[complete.cases(raw_dat),]
}
fhat <- ks::kde(x=corr_mat)
View(fhat)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
+col = viridis::viridis(20), xlab = "x", ylab = "y")
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col = viridis::viridis(20), xlab = "x", ylab = "y")
points(fhat$x)
contour.95 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["95%"])[[1]])
points(contour.95)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col=viridis::viridis(20), xlab = "x", ylab = "y")
points(contour.95)
fhat <- kde(x=corr_mat)
plot(fhat,  cont=c(25,50,75,95), col="black")
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col=viridis::viridis(20), xlab = "x", ylab = "y")
points(contour.95)
contour.95 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["95%"])[[1]])
contour.96 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["96%"])[[1]])
contour.5 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["5%"])[[1]])
points(contour.5)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col=viridis::viridis(20), xlab = "x", ylab = "y")
points(contour.5)
contour.1 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["5%"])[[1]])
points(contour.1)
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col=viridis::viridis(20), xlab = "x", ylab = "y")
points(contour.1)
contour.1 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["1%"])[[1]])
image(fhat$eval.points[[1]], fhat$eval.points[[2]], fhat$estimate,
col=viridis::viridis(20), xlab = "x", ylab = "y")
points(contour.1)
plot(fhat,  cont=c(25,50,75,95), col="black")
(
points(contour.1)
)
contour.96 <- with(fhat,contourLines(x=eval.points[[1]],y=eval.points[[2]],
z=estimate,levels=cont["96%"])[[1]])
points(contour.95)
points(contour.5)
plot(fhat,  cont=c(25,50,75,95), col="black")
points(contour.5)
plot(fhat, display = "image", xlab = "x", ylab = "y", col = viridis::viridis(20))
plot(fhat, display = "image", xlab = "Discharge", ylab = "DO", col = viridis::viridis(20))
View(corr_mat)
points(fhat$x)
plot(fhat, display = "image", xlab = "Discharge", ylab = "DO", col = viridis::viridis(10))
plot(fhat, display = "filled.contour", cont = seq(5, 95, by = 10),
xlab = "x", ylab = "y", col.fun = viridis::viridis)
plot(fhat, display = "slice", cont = seq(5, 95, by = 10), add = TRUE)
fhat <- kde(x=corr_mat, xmin=c(-5, -5), xmax=c(10, 15))
plot(fhat, display = "filled.contour", cont = seq(5, 95, by = 10),
xlab = "x", ylab = "y", col.fun = viridis::viridis)
plot(fhat, display = "slice", cont = seq(5, 95, by = 10), add = TRUE)
fhat <- kde(x=corr_mat, xmin=c(-5, -5), xmax=c(10, 20))
plot(fhat, display = "filled.contour", cont = seq(5, 95, by = 10),
xlab = "x", ylab = "y", col.fun = viridis::viridis)
plot(fhat, display = "slice", cont = seq(5, 95, by = 10), add = TRUE)
install.packages("dygraphs")
library(dygraphs)
dygraph(fhat)
dygraph(plot(fhat))
View(contour.5)
contour.5[["x"]]
data = corr_dat
n_cluster = range(1, 20)
n_cluster = seq(1,20)
kmeans = kmeans(n_cluster=i).fit(data)
for(i in n_cluster){
kmeans = kmeans(n_cluster=i).fit(data)
}
for(i in n_cluster){
kmeans = kmeans(n_cluster=i).fit(data)
}
for(i in n_cluster)
kmeans = kmeans(n_cluster=i).fit(data)
for(i in n_cluster)
kmeans
for(i in n_cluster)
kmeans = kmeans(n_cluster=i).fit(data)
cl = kmeans(data,2)
plot(data, col = cl$cluster)
cl = kmeans(data,10)
plot(data, col = cl$cluster)
library(magrittr)  # to use piping %>%
library(ggplot2)   # for ploting
library(MASS)      # to calculate the pseudo-inverse of a matrix
library(caret)     # to center our data by subtracting its mean
library(reshape2)  # for data manipulation
install.packages(c('magrittr', 'MASS', 'caret', 'reshape2'))
install.packager('magrittr')
install.packages('magrittr')
install.packages('MASS')
install.packages('caret')
install.packages('reshape2')
library(magrittr)  # to use piping %>%
library(ggplot2)   # for ploting
library(MASS)      # to calculate the pseudo-inverse of a matrix
library(caret)     # to center our data by subtracting its mean
library(reshape2)  # for data manipulation
#function to remove duplicate data
remove_dupe <- function(raw_dat){
is_dupe = duplicated(raw_dat$dateTimeUTC) |
duplicated(raw_dat$dateTimeUTC, fromLast=TRUE)
dupes = raw_dat[is_dupe,]
dupe_key = factor(paste(dupes$dateTimeUTC, dupes$value))
keepers = data.frame()
for(k in levels(dupe_key)){
dupe_group_inds = which(dupe_key == k)
dupe_group = dupes$flagID[dupe_group_inds]
keep = dupe_group_inds[dupe_group == 'Bad Data'][1]
if(is.na(keep)) keep = dupe_group_inds[1]
keepers = rbind(keepers, dupes[keep,])
}
raw_dat = filter(raw_dat, ! is_dupe) %>%
bind_rows(keepers) %>%
arrange(dateTimeUTC)
raw_dat
}
#function to fill missing time stamps with NA
fill_time <- function(raw_dat){
time_interval = as.numeric(difftime(raw_dat$dateTimeUTC[2],
raw_dat$dateTimeUTC[1]))
full_dat = seq.POSIXt(raw_dat$dateTimeUTC[1],
raw_dat$dateTimeUTC[nrow(raw_dat)], by=paste(time_interval, 'min'))
filled = full_join(data.frame(dateTimeUTC=full_dat), raw_dat)
filled
}
#remove rows with NA for any variables
remove_na <- function(raw_dat){
raw_dat[complete.cases(raw_dat),]
}
#my data (DO and Discharge)
my_DO <- read.csv("outlier_detect_test_DO.csv")
my_disch <- read.csv("outlier_detect_test_disch.csv")
my_DO$dateTimeUTC <- as.POSIXct(my_DO$dateTimeUTC, tz='UTC')
my_disch$dateTimeUTC <- as.POSIXct(my_disch$dateTimeUTC, tz='UTC')
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
disch <- fill_time(remove_dupe(my_disch))
corr_dat <- data.frame(disch = disch$value,
DO = DO$value)
corr_dat <- corr_dat[complete.cases(corr_dat),]
library(plyr)
#my data (DO and Discharge)
my_DO <- read.csv("outlier_detect_test_DO.csv")
my_disch <- read.csv("outlier_detect_test_disch.csv")
my_DO$dateTimeUTC <- as.POSIXct(my_DO$dateTimeUTC, tz='UTC')
my_disch$dateTimeUTC <- as.POSIXct(my_disch$dateTimeUTC, tz='UTC')
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
library(magrittr)  # to use piping %>%
library(ggplot2)   # for ploting
library(MASS)      # to calculate the pseudo-inverse of a matrix
library(caret)     # to center our data by subtracting its mean
library(reshape2)  # for data manipulation
library(plyr)
#function to remove duplicate data
remove_dupe <- function(raw_dat){
is_dupe = duplicated(raw_dat$dateTimeUTC) |
duplicated(raw_dat$dateTimeUTC, fromLast=TRUE)
dupes = raw_dat[is_dupe,]
dupe_key = factor(paste(dupes$dateTimeUTC, dupes$value))
keepers = data.frame()
for(k in levels(dupe_key)){
dupe_group_inds = which(dupe_key == k)
dupe_group = dupes$flagID[dupe_group_inds]
keep = dupe_group_inds[dupe_group == 'Bad Data'][1]
if(is.na(keep)) keep = dupe_group_inds[1]
keepers = rbind(keepers, dupes[keep,])
}
raw_dat = filter(raw_dat, ! is_dupe) %>%
bind_rows(keepers) %>%
arrange(dateTimeUTC)
raw_dat
}
#function to fill missing time stamps with NA
fill_time <- function(raw_dat){
time_interval = as.numeric(difftime(raw_dat$dateTimeUTC[2],
raw_dat$dateTimeUTC[1]))
full_dat = seq.POSIXt(raw_dat$dateTimeUTC[1],
raw_dat$dateTimeUTC[nrow(raw_dat)], by=paste(time_interval, 'min'))
filled = full_join(data.frame(dateTimeUTC=full_dat), raw_dat)
filled
}
#remove rows with NA for any variables
remove_na <- function(raw_dat){
raw_dat[complete.cases(raw_dat),]
}
#my data (DO and Discharge)
my_DO <- read.csv("outlier_detect_test_DO.csv")
my_disch <- read.csv("outlier_detect_test_disch.csv")
my_DO$dateTimeUTC <- as.POSIXct(my_DO$dateTimeUTC, tz='UTC')
my_disch$dateTimeUTC <- as.POSIXct(my_disch$dateTimeUTC, tz='UTC')
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
disch <- fill_time(remove_dupe(my_disch))
corr_dat <- data.frame(disch = disch$value,
DO = DO$value)
corr_dat <- corr_dat[complete.cases(corr_dat),]
corr_mat <- data.matrix(corr_dat)
X <- data.matrix(corr_dat)
View(X)
View(corr_dat)
View(X)
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
X <- corr_dat[complete.cases(corr_dat),]
X%>%ggplot(aes(x=`Latency (ms)`,y=`Throughput (mb/s)`))+
geom_point(color='blue')
View(X)
X%>%ggplot(aes(x=`disch`,y=`DO`))+
geom_point(color='blue')
my_temp <- read.csv("outlier_detect_test_temp.csv")
s
my_temp <- read.csv("outlier_detect_test_temp.csv")
my_temp$dateTimeUTC <- as.POSIXct(my_temp$dateTimeUTC, tz='UTC')
temp <- fill_time(remove_dupe(my_temp))
corr_dat <- data.frame(Temp = temp$value,
DO = DO$value)
X <- corr_dat[complete.cases(corr_dat),]
X%>%ggplot(aes(x=`disch`,y=`DO`))+
geom_point(color='blue')
View(my_temp)
my_temp <- read.csv("outlier_detect_test_temp.csv")
my_temp$dateTimeUTC <- as.POSIXct(my_temp$dateTimeUTC, tz='UTC')
my_temp <- read.csv("outlier_detect_test_temp.csv")
my_temp$dateTimeUTC <- as.POSIXct(my_temp$dateTimeUTC, tz='UTC')
temp <- fill_time(remove_dupe(my_temp))
View(my_temp)
corr_dat <- data.frame(Temp = temp$value,
DO = DO$value)
temp <- fill_time(remove_dupe(my_temp))
corr_dat <- data.frame(Temp = temp$value,
DO = DO$value)
temp <- fill_time(remove_dupe(my_temp))
library(plyr)
library(zoo)
temp <- fill_time(remove_dupe(my_temp))
#my data (DO and Discharge)
my_DO <- read.csv("outlier_detect_test_DO.csv")
my_disch <- read.csv("outlier_detect_test_disch.csv")
my_DO$dateTimeUTC <- as.POSIXct(my_DO$dateTimeUTC, tz='UTC')
my_disch$dateTimeUTC <- as.POSIXct(my_disch$dateTimeUTC, tz='UTC')
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
library(plyr)
library(ggplot2)
library(ks)
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
#remove duplicates then fill with NA
DO <- fill_na(remove_dupe(my_DO))
